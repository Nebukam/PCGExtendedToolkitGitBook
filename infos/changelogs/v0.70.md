---
description: Tracking changes since 0.68
icon: tag
---

# v0.70

> **Yes, 0.69 got skipped**. It was mostly bugfixes, and I ended up pushing a lot of its content under the 0.68.xx tags — I'm sure some of you will see that as a _nice_ missed opportunity.

{% hint style="success" %}
This update is two fold : on one hand, there's the update for the 5.7 version of the engine, and on the other end there's a backport of all the good things I did for 5.7 into 5.6!&#x20;

This also means that non including critical bugfixes, this is the last release for 5.6, **further development will happen for 5.7 only.**
{% endhint %}

## 5.7 Specifics

As some of you may have seen, 5.7 introduces a new _data type registry_; allowing a much smoother management of custom PCG data types. The most visible impact as a PCG user is **icons**!

<figure><img src="../../.gitbook/assets/image (83).png" alt=""><figcaption></figcaption></figure>

Colors are exposed for you to tweak under `Project Settings / PCGEx` . There's sensible defaults for now; and more importantly : plugins settings have changed their base type and registry so those have been reset by the update.&#x20;

> If you had tweaks done in those settings, you can retrieve them in the `DefaultEngine.ini` and move the PCGEx stuff to `DefaultGame.ini` instead.\
> Look for `[/Script/PCGExtendedToolkit.PCGExGlobalSettings]` !

A slightly revised set of icons should now make it more obvious that inputs, in most cases, accept multiple data.&#x20;

<details>

<summary>Vtx, Edges and Paths still have the extra icon, why?</summary>

Vtx, Edges and Path are still just points. Making them their own types would have made them more narrow than "just point", and not only is it untrue, there's also zero benefit on my end to make them their own type.

So yup, they'll keep that little extra icon next to the _now more meaningful than ever_, **points** icon.

</details>

## New Nodes

{% hint style="info" %}
Some of those already made it 0.69.x but with no proper heads-up.
{% endhint %}

### [Tuple](../../node-library/quality-of-life/tuple.md)

A nifty (_if I say so_) quality of life node that lets you create mini-data-table in place. It fills the gap between either having to create a struct + datable assets (_ugh_) or combine a bazillion of create attribute nodes + merge attributes (_ugh_) when all you need really is a glorified map.&#x20;

<figure><img src="../../.gitbook/assets/image (90).png" alt=""><figcaption></figcaption></figure>

> There's no limit to the number of attributes/types/row you can put in there, it just becomes a bit clunky with large tables (that would better maintained as a data table or asset); but it save so much hassle when you need smaller dataset without the boilerplates

The _Composition_ section of the detail panel covers the "struct definition" and default values, and _Values_ array represent individual rows in the final attribute set.

{% columns %}
{% column %}
<figure><img src="../../.gitbook/assets/image (92).png" alt=""><figcaption></figcaption></figure>
{% endcolumn %}

{% column %}
There's a handful of basic types readily available, including Color _(to get a nice color picker)_ and Enum _(which is a bit buggy but functional)_

<mark style="color:$success;">It's worth mentioning that it's actually deceiptively simple to add your custom types in there from C++ — see</mark> [<mark style="color:$success;">here</mark>](https://github.com/Nebukam/PCGExtendedToolkit/blob/b2f0b49df01838fdb64b1eea5bb5a580119c8e1f/Source/PCGExtendedToolkit/Public/Constants/PCGExTuple.h#L234)<mark style="color:$success;">.</mark>

{% hint style="info" %}
**Only change the type of the value in the Composition.** Changing it on the row will only reset the value and force back the type defined under Composition.
{% endhint %}
{% endcolumn %}
{% endcolumns %}

<details>

<summary>That's a weird format tho, why?</summary>

Working on this node I stumbled upon `TInstancedStruc`t, which is a very handy abstract that turns into a custom picker in the detail panel, much like instanced objects. It's a bit clunky because the picker is available all the time, so in that sense it's a bit error prone for what I'm doing with it here (_values being reset if you try to change it and I change it back in code_), but that makes it super easily extendable with new types.

The model is still one header = one attribute, so you can't have a single type that creates multiple attributes (_at the moment, at least_); however you can easily expose more friendly controls on values or enforce units, conversions etc in a programmatic way which can be desirable — Color and Enums are good example of that.

</details>

### [Path : Slide](../../node-library/paths/slide.md)

<figure><img src="../../.gitbook/assets/image (84).png" alt=""><figcaption></figcaption></figure>

This one with look silly but really is a welcome addition for folks doing a lot spatial filtering/data-matching based on path _segments_. It can slide path points along the path and store the original position (_and  restore it later on_)

> Since path "segments" are primarily identified by the first point of the segment, it's often very annoying or tricky to test against these points as opposed to, say, the middle of the segment. `Path : Slide` works around that problem by letting you literally **move the points somewhere else on the segment so they're located where it make sense for testing**, and you can restore the original aspect with that same node later down the line.

### [Self Pruning](../../node-library/sampling/self-pruning.md)

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

PCGEx' very own self pruning node. Comes with a _precise_ mode to do highly precise OOB x OOB checks (_Object Oriented Box_) - very slow, but preserve a lot more points.

_Also works using PCGEx' sorting rules for a more straightforward pruning order._

### [Sample : Sockets](../../node-library/sampling/sockets.md)

You now have a one-stop node for all your mesh sockets needs.&#x20;

<figure><img src="../../.gitbook/assets/image (87).png" alt=""><figcaption></figcaption></figure>

> It takes a list of points with mesh references on them (_what you'd get from staging or grammar_) and extract all, or filtered sockets and output them as a new set of points.
>
> _You can also selectively choose which of the socket axis inherit the point scale, which is handy for grammar module that gets stretched over a specific axis and you want the socket to retain its original scale._

<figure><img src="../../.gitbook/assets/image (86).png" alt=""><figcaption></figcaption></figure>

#### Socket support in Mesh Collections

Part of this update also include socket support directly as part of [mesh-collection.md](../../node-library/assets-management/collections/mesh-collection.md "mention")!

### [Cluster : Centrality](../../node-library/clusters/centrality.md)

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

<div><figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure> <figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure> <figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure></div>

Thanks to Scheat, you get a new "Centrality" node to compute clusters' [betweenness centrality](https://en.wikipedia.org/wiki/Betweenness_centrality). Very expensive on huge graphs, has the option to compute a (much cheaper) approximation using a randomly smaller subset of nodes. <mark style="color:$info;">Alternatively, Filters can also be used to pick which vtx should be used as source for computation, allowing for some really fancy effects.</mark>

> I will likely add more centrality types later, such as **closeness, degree** centrality and a few other possibly useful ones — so some refactor is to be expected, but ultimately the output will remain a simple per-vtx scalar.

### [Recursion Tracker](../../node-library/quality-of-life/recursion-tracker.md)

After messing with recursion I found myself needing the same set of nodes over and over to track recursion progress and stop it using a varying combination of count/collections criterias — so I wrapped that in a single handy node that output a `param` data that you can pass around.

{% hint style="success" %}
The default behavior is to pass around the same pointer, the data is tracked using the `tag:value` pattern to avoid needless copies.

The data itself is vanilla attribute set, so you can add your own data to it or merge it, **as long as tags are preserved**.
{% endhint %}

<figure><img src="../../.gitbook/assets/image (93).png" alt=""><figcaption><p>You can see an example of it being used in the tensor debug subgraph, in the example project</p></figcaption></figure>

> It's most useful to keep recursive graphs self-contained and ditch a bunch of nodes — especially in the context of recursion this avoids N^<sup>2</sup> copies of ops nodes & the associated garbage data they generate.

### Merge Path <sup><mark style="color:$warning;">Subgraph<mark style="color:$warning;"></sup>

A subgraph that "merge" overlaping path and breaks them back into single paths. A bit of a misnomer.

### Merge Cells <sup><mark style="color:$warning;">Subgraph<mark style="color:$warning;"></sup>

A subgraph that merge adjacent cells based on picker / is inside.

### Merge Cells (Cluster) <sup><mark style="color:$warning;">Subgraph<mark style="color:$warning;"></sup>

A subgraph that merge adjacent cells based on picker / is inside.

## Filters

### [Segment Cross](../../node-library/filters/filters-points/spatial/segment-cross.md)

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

A simple filter that work with paths, for paths. Check if any segment from the input paths intersects with the tested data "as paths". **Especially useful with** [split.md](../../node-library/paths/split.md "mention")**.**

### [Contains (Hash)](../../node-library/filters/filters-points/simple-comparisons/contains-hash.md)

<figure><img src="../../.gitbook/assets/image (88).png" alt=""><figcaption></figcaption></figure>

Contains (Hash) does a strict hash comparison to check if a point **attribute value is part of one or multiple sets**. <mark style="color:$warning;">It is</mark> <mark style="color:$warning;"></mark><mark style="color:$warning;">**type sensitive**</mark><mark style="color:$warning;">, so a</mark> <mark style="color:$warning;"></mark><mark style="color:$warning;">`float = 0`</mark> <mark style="color:$warning;"></mark><mark style="color:$warning;">won't have the same hash as</mark> <mark style="color:$warning;"></mark><mark style="color:$warning;">`double = 0`</mark><mark style="color:$warning;">.</mark> Be careful!

### [Random (Ratio)](../../node-library/filters/filters-points/random-1.md)

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

A filter that reproduces the behavior of the vanilla Random Choice node, but usable with PCGEx' filter ecosystem. _Lets you pick a random number of items, a percentage, and those values can be driven by Data domain attributes._

## Tweaks

#### Stable Seeds

[@staminajim](https://github.com/staminajim) did fix some really old unstable seed-generation code for some shiny, platform-wide stable seed generation for all seed-things PCGEx. This guarantees deterministic seeds on stuff like clusters as there was some minor discrepancies that would cascade into major ones.&#x20;

#### Other tweaks

* [uber-filter-collection.md](../../node-library/filters/uber-filter-collection.md "mention") now supports _any_ input. Non-points data will create a temporary _to points_ proxy data for the sake of testing. <mark style="color:$warning;">Be careful with splines and volumes, as their conversion to points uses some internal framework defaults that may be misleading as far as spatial representation goes.</mark>
* Mesh to Cluster now support extracting **Vertex Color** & **UV channels**
* **Edge Union Metadata** is now correct when the edge is a result of a partial overlap from a `point/edge` intersection.
* Rudimentary material override for Spline Mesh (Simple)!
* [Heuristic Attribute](../../node-library/pathfinding/heuristics/hx-attribute.md) now lets you use raw attribute values instead of forcing automatic normalization on you.&#x20;
* The old `Attributes to Tags` has been redubbed [attributes-to-tags.md](../../node-library/misc/attributes-to-tags.md "mention") as it supports hoisting to Data domain on top of tags. Data domain now respect original attribute type (was previously defaulting to `FString`)
* [find-point-on-bounds.md](../../node-library/clusters/find-point-on-bounds.md "mention") (cluster) + [find-point-on-bounds.md](../../node-library/misc/find-point-on-bounds.md "mention") now support reading UVW from data domain, as well as usage of Best Fit Plane
* Full refactor of OOB code & Best Fit Plane maths so they prioritize best orientation with the world axis as opposed to producing correct yet weird results. This affect a whole lot of nodes but should be unnoticeable except for [Bounds Axis to Points](../../node-library/misc/bounds-axis-to-points.md) and [Points to Bounds](../../node-library/misc/points-to-bounds.md). &#x20;

{% hint style="success" %}
Best Fit Plane by default will align the X axis over the longest dimension, Y on the middle one and Z over the  smallest one. **It's worth noting because it can now be reliably used to find the longest, smallest or median axis of any group of points.**
{% endhint %}

* Proper blending on Path x Bounds Intersection node along with **some&#x20;**<mark style="color:$success;">**new extra outputs**</mark>**, and&#x20;**<mark style="color:$primary;">**some removed**</mark>

<figure><img src="../../.gitbook/assets/image (85).png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
`IsInside` has been removed as an output from this node, use [Filter : Bounds](../../node-library/filters/filters-points/spatial/bounds.md) instead.
{% endhint %}

## Bugfixes

A lot of them. Various crashes and typos that would be revealed by very edgy special cases from people doing very odd things.
