---
description: Tracking changes since 0.73
icon: tag
---

# v0.74

## 0.74 is a big update with important changes; make sure to <mark style="color:$info;">at least scan the titles</mark> in case something would unexpectedly affect your workflow!

{% hint style="success" %}
PCGEx is finally out of FAB limbo -- You can download it through the launcher again!
{% endhint %}

{% hint style="danger" %}
There's been some moving around/renaming files again.\
&#xNAN;_&#x53;orry for the svn admin, I'll try to avoid that as much as possible in the future >.<_
{% endhint %}

## Major Tweaks

### Cell Processing

I've pushed a major refactor regarding how cells/contours are detected in clusters. This affects [Broken link](/broken/pages/bY1TJGYS5T6UdHkpRFXR "mention"), [Broken link](/broken/pages/aZD4QEa5DkbJBAmBzLPz "mention"), [Broken link](/broken/pages/e0e6N5aSAK4BztLj5JVn "mention") and [Broken link](/broken/pages/J9Ule3zn7zPZU6pWrsrT "mention").&#x20;

<details>

<summary> But why?</summary>

The primary reason is that as I added Manhattan and Chebyshev voronoi modes, the topology of the generated cluster became slightly more complex and "rigid" with perfect orthogonal angles that created a LOT of false positive/negative in the existing cell detection code, and it was a mess. _It does naturally create problematic cells that require fusing despite the update_.

I lost of a lot of time trying to fix it without proper success so I ended up taking another more reliable approach entirely : I now build a [Doubly Connected Edge List](https://en.wikipedia.org/wiki/Doubly_connected_edge_list) from the clusters, which is infinitely more reliable than my previous angle-based approach.

</details>

This is an important one as <mark style="color:$warning;">it will break some of your existing settings</mark>; **specifically node count constraints** : the previous code was not counting properly (adding one to all counts), this is not true anymore. That means cell constraints with the old value will not return the same results now.

> For example to isolate quads, you had to use "5" — now it's "4".

Code has been optimized a lot as well and [Broken link](/broken/pages/bY1TJGYS5T6UdHkpRFXR "mention")rules have changed a bit :

* **Seeds will only capture the cells that&#x20;**_**contains**_**&#x20;their position**, instead of "close enough".\
  &#xNAN;_&#x54;his more closely match functionality of the holes pin of Find All Cells._
* Seeds that are outside of any cells **can only capture the wrapper cell**.

#### Cell Bounds outputs

Cells finder nodes now have an additional, optional output : **Cell Bounds**.\
It outputs a single dataset per cluster (so, per connected edge group) that contains one point per cell.&#x20;

<figure><img src="../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption><p>Cheap trick to find nicely spaced out cells</p></figcaption></figure>

### Find Cell / Find All Cells (Bounded) <sup><mark style="color:$success;">New Nodes<mark style="color:$success;"></sup>

Cells finding nodes now have their partition friendly (Bounded) companion nodes that replicates the [Broken link](/broken/pages/YBp8J5M6WZSz6362EmCt "mention") behavior to only output relevant cells to different bins!

<figure><img src="../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

### [Cell Diagram](/broken/pages/kZSzQGEqZPZltG3ww07l) <sup><mark style="color:$success;">New Node<mark style="color:$success;"></sup>

A handy node that outputs a diagram based on cell adjacency.

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

### Cell Picking Expansion <sup><mark style="color:$info;">New Feature<mark style="color:$info;"></sup>

Cell nodes now expose growth parameters (_global or per seed_) to output neighboring cells up to a certain depth. _The same logic applies to holes and "grows" the holes._

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

> Which seed gets ownership of the cells supports:
>
> * Seed order (first come first served)
> * Closest distance (world space or projected)
> * Best Candidate (uses sorting rules)

### Dual Graph <sup><mark style="color:$success;">New Node<mark style="color:$success;"></sup>

A simple diagram node that outputs clusters' dual graph (_edges become vtx and vtx are split into edges_) — fairly niche case but I've been wanting to add that for ages.

<figure><img src="../../.gitbook/assets/image (143).png" alt=""><figcaption></figcaption></figure>

### Data Matching

Data matching got an overhaul — I don't expect a lot of people have used those nodes because it's a fairly niche feature; but it plays a major role in helping reduce the need for loops in a bunch of nodes. The way it worked (and still works) is for most nodes that have "secondary" inputs that synergize with the main inputs (i.e [Broken link](/broken/pages/iyQqn1XpaBxVg9RJtSOW "mention")), [Broken link](/broken/pages/BsXbNk7bs6LgoEwwW9Ge "mention") lets you choose which secondary input can be "matched" with the processed ones.

There's new match nodes & tweaked ones:

* [Broken link](/broken/pages/UQZl1TKYSAtvsPSwlErk "mention") now supports additional **Any** and **All**
* [Broken link](/broken/pages/vYLIkyhteGhPuTaVdfCz "mention") is now fully implemented and supports recursion

<mark style="color:$danger;">The</mark> [Broken link](/broken/pages/EFnX5Gwvg1fZdMy74Yxy "mention") <mark style="color:$danger;">has been</mark> <mark style="color:$danger;">deprecated</mark> and instead its functionality has been <mark style="color:$success;">migrated to</mark> [Broken link](/broken/pages/XulO46DjGnPZAzyA14mc "mention") by adding Data Matching support to it; with overall much greater flexibility.

<figure><img src="../../.gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

### Heuristics&#x20;

<figure><img src="../../.gitbook/assets/image (141).png" alt=""><figcaption></figcaption></figure>

Slightly improved heuristics handling to squeeze some more speed (better caching and allocations etc.) with two new heuristics:

* [Broken link](/broken/pages/PL9t0sekZAGZlxfUONAw "mention")\
  Penalize or favor turns in immediate search. _This is subtely different from_ [Broken link](/broken/pages/XYW10a34B2ovE8I0fGOS "mention") _as the latter builds up on path direction._
* [Broken link](/broken/pages/BZgLX1Awvx45u2S2J5Du "mention")\
  Alternative to [Broken link](/broken/pages/iXwZzVrOePzZXNhwkCmX "mention") this one favors changes in values between neighbors

> This _should_ not affect existing results.

### Manhattan + Chebyshev

The [Broken link](/broken/pages/vM7M7htQ8tftXkByoPgi "mention") node now supports Manhattan and Chebyshev mode!

<div><figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure> <figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure></div>

{% hint style="warning" %}
Due to the very unique topology of these graph, if you want to find cells you have to use [Broken link](/broken/pages/KMGvuuSliOeNL6dYyGqH "mention") to find point/edge and edge/edge intersections; as some edge perfectly overlap and align, messing with my algorithms.
{% endhint %}

<div><figure><img src="../../.gitbook/assets/image (2) (1) (1) (1).png" alt=""><figcaption><p>Hull without fuse</p></figcaption></figure> <figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption><p>Hull after fuse</p></figcaption></figure></div>

### Tensors Extrude Refactoring

Long overdue, I've been doing a lot of cleanup on the tensor side. A few optimizations, and a major overhaul of the [Broken link](/broken/pages/O01P6yzAGrCWkFKdVUoq "mention") code to make it more maintainable and _extendable_.

* Mutators now support a component-wise scale, so you can basically "flatten" effectors.
* More robust extrusions intersection/stop/merge detection

<figure><img src="../../.gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

***

## Flood Fill Module

[Broken link](/broken/pages/E9KTJGb7xOvs8XPALY5X "mention") got its fair share of improvements as well, growing to extents that made it a good candidate for a new module entirely. It comes with a _lot_ of very specific code & subnodes that not everybody will care about so I figured let's make it optional.

{% hint style="danger" %}
Flood fill heuristics have been moved to an optional Fill Control subnodes instead of being a pin on the Flood Fill node itself.
{% endhint %}

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

Comes with some new fill controls:

* [Broken link](/broken/pages/1QdAeHeqaNGAOhKns0Zi "mention")&#x20;
* [Broken link](/broken/pages/7vWyEXQU2OzWPHqunNYO "mention")
* [Broken link](/broken/pages/QM5pgeUSkqHwIRU4WQMD "mention")
* [Broken link](/broken/pages/wkH1i1S0UlPCJSWEYE14 "mention")
* [Broken link](/broken/pages/QM5pgeUSkqHwIRU4WQMD "mention")

> Fill controls affect which vtx is flooded next, if they can be flooded, and whether the diffusion should stop there.

On the topic of heuristics; I also added alternative ways to process & weight heuristics. I was working with paths and was trying and failing to do some really subtle balancing so here goes:

<div><figure><img src="../../.gitbook/assets/image (145).png" alt=""><figcaption><p>Weighted Average</p></figcaption></figure> <figure><img src="../../.gitbook/assets/image (148).png" alt=""><figcaption><p>Geometric Mean</p></figcaption></figure> <figure><img src="../../.gitbook/assets/image (147).png" alt=""><figcaption><p>Harmonic Mean</p></figcaption></figure></div>

* **Weighted Average** \
  <sup>_default, old mode. Balanced blending of all heuristics. Scores normalized to \[0,1] range._</sup>
* **Geometric Mean**\
  <sup>_Sensitive to extremes. A single low score significantly reduces the combined result._</sup>
* **Weighted Sum**\
  <sup>_Direct weight contribution with no normalization. Scale varies with heuristic count._</sup>
* **Harmonic Mean**\
  <sup>_Heavily emphasizes low scores. Useful when lower costs should dominate the result._</sup>
* **Min**\
  <sup>_Takes the minimum score across all heuristics. Most permissive - any heuristic can allow passage._</sup>
* **Max**\
  <sup>_Takes the maximum score across all heuristics. Most restrictive - any heuristic can block passage._</sup>

***



## Asset Staging toolchain

I've solidified the Collection Staging toolchain to make it more useful and leverage more of the various possibilities the system can offer. Following up the recent refactor of the collection architecture and the introduction of the registry on the C++ side, the **Collection Map** workflow is now the preferred approach : <mark style="color:$warning;">this will be reflected in an update of the nodes defaults settings</mark>.&#x20;

> This will affect the [Broken link](/broken/pages/cLPLrkgysgkezVpY7EH9 "mention") node as well as [Broken link](/broken/pages/ZS9nQlgX6BfSz6GkhjLz "mention")

<details>

<summary><strong>Renamed staging  nodes</strong></summary>

| Old Name            | New Name                     |
| ------------------- | ---------------------------- |
| Asset Staging       | **Staging :** **Distribute** |
| Path : Spline Mesh  | **Staging : Spline Mesh**    |
| PCGDataAsset Loader | **Staging : Load PCGData**   |
| Socket Staging      | **Staging : Load Sockets**   |

</details>

<details>

<summary>Why the refocus to collection maps?</summary>

The collection map workflow consist to serialize multiple indices (picks) on the points and output which collections or subcollections are relevant to those picks to a roaming, lightweight mergeable attribute set.

This allows to do all kind of processing operation and data retrieval with minimal attribute overhead (a single `int64`)

I've always wanted to be able to expand the collection system in new ways to make it less of a "narrow" tool; the recent addition of [Broken link](/broken/pages/kf8UVB0rsM4sZAMTZwQq "mention") and the experimental [valency](../../working-with-pcgex/valency/valency/ "mention") ecosystem, I started wanting more.

</details>

### Asset Collections custom properties

I'm really happy to say that PCGEx asset <mark style="color:$success;">collections now support custom properties</mark>. It's limited and only supports basic, PCG-friendly types for now.

Properties schema is declared at the collection level with default values, and each field can be overwritten per-entry.&#x20;

> It is **very easily extendable with C++** so you can add really custom stuff if that's your kink. It's relying on `FInstancedStruct` and each struct is responsible for writing data to points/attribute sets.&#x20;
>
> It's leveraging the new [#pcgexproperties-module](v0.74.md#pcgexproperties-module "mention") so you'll only need dependencies on that one and `PCGExCore`.

<div><figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption><p>Declare defaults in collection settings</p></figcaption></figure> <figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption><p>Override per-entry values</p></figcaption></figure></div>

Segue into the new node used to read those properties back onto the points :

### [Staging  : Load Properties](/broken/pages/GBQh6HtAHpTrEC9gSZRO) <sup><mark style="color:$success;">New node<mark style="color:$success;"></sup>

<figure><img src="../../.gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

Allows you to write picked entries custom properties their respective points.

***

## [Valency](../../working-with-pcgex/valency/valency/) <sup><mark style="color:$warning;">Experimental<mark style="color:$warning;"></sup>

A new experimental feature enabling **ultra-flexible WFC-like solving on clusters**. I won't elaborate too much just yet, but know it's there. _There's an ultra-basic barebone example in the example project for 5.7 but at this point I wouldn't expect anyone to do anything useful with it_

> There's some [basic doc available](../../working-with-pcgex/valency/valency/) (Ai-generated from the codebase)

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Most editing and live edit/reload requires you to activate the new **Valency editor mode**.
{% endhint %}

***

## Low level stuff & API

### Data Stealing

A couple of nodes now have the ability to steal data — this is disabled by default, but super handy : the stolen data cost is basically zero.

<div><figure><img src="../../.gitbook/assets/image (4) (1) (1).png" alt=""><figcaption></figcaption></figure> <figure><img src="../../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure> <figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure></div>

> This is especially useful for cluster nodes that support it, as duplicating cluster data can grow really expensive.

<details>

<summary>What's that?</summary>

Steal data is really powerful but really risky — be extra careful when using it.

The nodes that expose this option usually do "editing in place", copy the data as-is, change a few properties, output the copy.

When stealing the data is enabled, the node doesn't copy the data and instead modifies the input directly. This saves you from having more extra objects in memory, and is often very welcome.

{% hint style="danger" %}
If stealing data, make absolutely sure that the data pinned into the stealer is exclusively used by that node and no other.
{% endhint %}

</details>

It's currently supported by a few candidates :

* [Broken link](/broken/pages/FHOHoihpZNLQtEbyp0Qw "mention")
* [Broken link](/broken/pages/cLPLrkgysgkezVpY7EH9 "mention")
* [Broken link](/broken/pages/bhbYCA0ByTkLgTaF07Pm "mention")
* [Broken link](/broken/pages/KWHvOq5oodduZpfamdA7 "mention")
* [Broken link](/broken/pages/f5xZk2yDnM3mvFWAaQr3 "mention")
* [Broken link](/broken/pages/PeKuw7nXb8zNHKbMf6rg "mention")
* [Broken link](/broken/pages/nxspiOM3y2yMubJMkV8F "mention")
* [Broken link](/broken/pages/V1NPEUYNCiBHeOhHEvF1 "mention")
* [Broken link](/broken/pages/LAnCQM2lmOrqTLBr0Qdt "mention")
* [Broken link](/broken/pages/120GKmEfbXpBPcydjfdR "mention")
* [Broken link](/broken/pages/GbKHjVm7VMy2hOnyChiy "mention") _(in write mode)_
* [Broken link](/broken/pages/fxk1TEhqWiJOilbozobQ "mention") _(in attribute mode)_
* [Broken link](/broken/pages/qnUULM7r9gJbLaBJNQnC "mention")&#x20;

### Cluster Prebuilt Data Cache Registry

This is one I'm really happy about. Cluster rely a lot on very focused data structure designed for specific tasks — Cells for example need a planar face graph to be built and traversed, Valency has an orbital cache, etc. Previously, those were built _on-demand_ by the node that needs them and ditched after execution.&#x20;

> This is problematic when working with top-level graph that need to be processed in partitions (runtime or otherwise) because each partitioned node rebuilds that data for itself.&#x20;

This is no longer the case : **you can enable building those different cache on higher grids** and the cache will be passed down to lower grids for other nodes to consume that data (or fall back to rebuilding it if it doesn't exists).&#x20;

There's two tiers of cache:

* **Native/Prebuild**, that'd be stuff I know already and can expose in very low-level settings that are reused and known when subgraphs are compiled (_Cells will leverage this_)
* **Opportunistic**, nodes can just push the data their computed to downstream nodes (_Valency will leverage this_)

{% hint style="info" %}
This isn't free because the cached data will stay longer in memory, but that's usually a desirable tradeoff.
{% endhint %}

***

### PCGExProperties Module

There's a new module to consolidate how I manage custom simple properties exposure. I started having too many different systems doing the same thing but different _(Tuple, Custom collection data, Valency custom module data...)_ so I've **consolidated things into a single module** and refactored other places to use that one solidified approach.

{% hint style="success" %}
Any new custom property will be available to the systems that use them : [Broken link](/broken/pages/OnicCtPRQefLs8dD8MSq "mention"), [valency](../../working-with-pcgex/valency/valency/ "mention") and [Broken link](/broken/pages/UXgxnf7YZ8yt1AXw1heR "mention")will seamlessly benefit from any additions and improvements.&#x20;
{% endhint %}

> UI Customization is a bit clunky for now; sorry about that. Unreal doesn't make it very friendly to integrate in existing system without extensive hacking; so I had to forfeit a few clicks on complex property types.

***

## Misc

Sorting rules can now **read values straight from tags** in the `tag:value` format. This was a necessary addition because of the above change; the old Merge Points by Tag had its own sort-by-tag logic which was nowhere else; and now it's available _everywhere_.

[Broken link](/broken/pages/Ox5T4SoLwRZhIdHBF9KV "mention") now exposes tolerance and have a more precise hash (see [#180](https://github.com/Nebukam/PCGExtendedToolkit/pull/180))

Edge Filter disambiguation

* "**Edge Filter :&#x20;**<mark style="color:$warning;">**Neighbors Count**</mark>" is now "**Edge Filter :&#x20;**<mark style="color:$success;">**Num Vtx**</mark>"
* "**Vtx Filter :&#x20;**<mark style="color:$warning;">**Neighbors Count**</mark>" is now "**Vtx Filter :&#x20;**<mark style="color:$success;">**Num Edges**</mark>"

> I know it's technically incorrect, but they were really hard to distinguish before.

### Optimizations

* Best Fit Plane has been refactored for speed and approximation - 5-50x speed up depending on cases. Nodes that were previously relying on precise min box now expose a `Precise Min Box` where relevant (true where it was used before) _Benefits Clusters, Cell nodes, Points to Bounds etc_
* Some very minor tweaks on cluster edge management

### Deprecations

Because [Broken link](/broken/pages/qjd3vAF8OHA922Tf1OGX "mention") is so good at what it does, I entirely removed the clunky "cleanup" options from the old [Broken link](/broken/pages/9I57MUYaYfxKbOrIzCWt "mention") node — it was not robust and had tons of edge cases, was a pain to maintain — I'm just happy to get rid of that.



