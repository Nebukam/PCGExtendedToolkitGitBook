---
description: Tracking changes since 0.70
icon: tag
---

# v0.71

{% hint style="info" %}
NOTE : This changelog includes patch changes as well (`0.71.1`, `0.71.2` etc)
{% endhint %}

## Icons, icons _(almost)_ everywhere

A lot of enums have been turned into an inline list of icons — I've always found dropdowns to be in the way of iteration, and lots of features are hidden behind dropdowns.&#x20;

<div><figure><img src="../../.gitbook/assets/image (106).png" alt=""><figcaption></figcaption></figure> <figure><img src="../../.gitbook/assets/image (108).png" alt=""><figcaption></figcaption></figure> <figure><img src="../../.gitbook/assets/image (107).png" alt=""><figcaption></figcaption></figure></div>

> Many nodes are notoriously complex, often requiring trial and error to get the right result. That process is now dramatically simpler!

<details>

<summary>Inlined enums</summary>

`EPCGExInputValueType` / `EPCGExInputValueToggle`

Constant / Attribute / _Disabled (contextual)_

<div align="left"><figure><img src="../../.gitbook/assets/image (110).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExOptionState`

Used mostly in generic node settings, for things that have an global default value in the plugin settings but can be overridden per-node.

Default / Enabled / Disabled

<div align="left"><figure><img src="../../.gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExFilterFallback` / `EPCGExFilterNoDataFallback`

Throw error / Pass / Fail

<div align="left"><figure><img src="../../.gitbook/assets/image (116).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExPointBoundsSource`

Scaled Bounds / Density Bounds / Bounds / Center

<div align="left"><figure><img src="../../.gitbook/assets/image (117).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExDistance`

Center / Spherical Bounds / Scaled Bounds

<div align="left"><figure><img src="../../.gitbook/assets/image (118).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExClusterElement`

<div align="left"><figure><img src="../../.gitbook/assets/image (119).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExAttributeFilter`

<div align="left"><figure><img src="../../.gitbook/assets/image (120).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExComparisonDataType`

<div align="left"><figure><img src="../../.gitbook/assets/image (121).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExScaleToFit`

<div align="left"><figure><img src="../../.gitbook/assets/image (122).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExJustifyFrom`

<div align="left"><figure><img src="../../.gitbook/assets/image (123).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExJustifyTo`

<div align="left"><figure><img src="../../.gitbook/assets/image (124).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExFitMode`

<div align="left"><figure><img src="../../.gitbook/assets/image (125).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExMinimalAxis`

<div align="left"><figure><img src="../../.gitbook/assets/image (126).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExMaterialVariantsMode`

<div align="left"><figure><img src="../../.gitbook/assets/image (127).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExEntryVariationMode` / `EPCGExGlobalVariationRule`

<div align="left"><figure><img src="../../.gitbook/assets/image (115).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExWinding` / `EPCGExWindingMutation`

<div align="left"><figure><img src="../../.gitbook/assets/image (114).png" alt=""><figcaption></figcaption></figure></div>

***

`EPCGExSortDirection`

<div align="left"><figure><img src="../../.gitbook/assets/image (113).png" alt=""><figcaption></figcaption></figure></div>



</details>

## Asset Editor Revamp

Put a lot of work (probably more than it shows) into building a custom editor for the asset collections, so they can be used much more efficiently than they used to!

<div><figure><img src="../../.gitbook/assets/image (128).png" alt=""><figcaption></figcaption></figure> <figure><img src="../../.gitbook/assets/image (129).png" alt=""><figcaption></figcaption></figure></div>

* Collection-level settings have been moved to their own tab so you can focus on either the assets or the collection itself.
* Entry mesh (or sub collection), as well as weight and category are now hoisted directly into the array item, so no more expending to get an overview on the content of the collection
* The same courtesy have been applied to material overrides
* Variations have now have a very condensed format
* There are visibility filters at the bottom
* Actions & tool buttons are now always visible in a condensed format at the top

## New Nodes

### [Transform Points](v0.71.md#transform-points)

<figure><img src="../../.gitbook/assets/image (130).png" alt=""><figcaption></figcaption></figure>

Not dissimilar to the stock' Transform Points node, the PCGEx version has a few addition tricks down its sleeves.

* **Every single property can be either a constant or read from a point attribute/property**
* Each component support two snapping modes: before offset and after offset.
  * Before Offset applies snapping on the random offset that's added on the existing value
  * After Offset applies the offset and then snap the result.
* Each component has an additional Scaling property exposed to apply a scale to the random range for that component.

{% hint style="success" %}
After Offset Snapping means **you can use this node without randomization**, <mark style="color:$success;">**for snapping alone**</mark>.
{% endhint %}

<figure><img src="../../.gitbook/assets/image (132).png" alt=""><figcaption><p>The same snapping options can be found in the "Variations" settings of the asset collections</p></figcaption></figure>

### [Collection to Module Infos](../../node-library/assets-management/collection-to-module-infos.md)

Added rudimentary support for grammar module settings directly as part of the asset collection, with a nice little node to **output module infos from PCGEx' collections**. _It support subcollection expansion and few other neat tricks to make your life easier._

<figure><img src="../../.gitbook/assets/image (131).png" alt=""><figcaption></figcaption></figure>

> More of that will come, I have a "Grammar Staging" node down the pipe that will work exactly like [asset-staging](../../working-with-pcgex/asset-staging/ "mention")but specifically for points coming out of the grammar workflow.

### [Write States](../../node-library/filters/write-states/)

the [write-states](../../node-library/filters/write-states/ "mention")node is the point-friendly version of what used to be called "Flag nodes". It takes [state-point.md](../../node-library/filters/write-states/state-point.md "mention")subnodes to do bitwise operation on an `int64` attribute.

{% hint style="warning" %}
`Flag Nodes` has been renamed [flag-nodes](../../node-library/clusters/metadata/flag-nodes/ "mention") and `Node Flag`  [node-flag.md](../../node-library/clusters/metadata/flag-nodes/node-flag.md "mention").\
&#xNAN;_`Cluster : Write States` supports_ [state-point.md](../../node-library/filters/write-states/state-point.md "mention") _nodes, there's not much difference between the two!_
{% endhint %}

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

### Parcels 2D <sup><mark style="color:$warning;">Subgraph<mark style="color:$warning;"></sup>

Made a decent re-usable subgraph out of the example for the subdivision part alone. It's an optimized alternative, although it's still a recursive loop; it has some fail safes to stop iterating for no good reason, and more interestingly, exposes filters so you can control stop split conditions "manually". _At worst, it's a good example itself on how to use the break recursion node!_

<figure><img src="../../.gitbook/assets/parcels.gif" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

## Bitmask Collections

A new type of data asset to create re-usable bitmasks across a project.&#x20;

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

{% hint style="success" %}
PCGEx now comes with the **3D Compass**, a default bitmask collection with 24 spatial directions.
{% endhint %}

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption><p>Bitmasks can now reference external assets to pick &#x26; compose more complex values </p></figcaption></figure>

Note that inside a bitmask collection, these entries come with a direction. This is to pave the way for WFC experimentations and streamline cluster state workflows — it's entirely optional.

## New Filters

Data Bounds Aspect

<figure><img src="../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

A simple collection-level filter that lets you do a numeric comparison against a variety of bounds aspects, from the usual `Extents`, `Min/Max`, `Size`, but also `Volume` and `Ratio`!

> I added that as I needed it for the parcel subgraph to ensure cells that were too small wouldn't be subdivided down problematic metrics. I might add a per-point version at some point for the aspect ratio.

## Tweaks

### [Path : Solidify](../../node-library/paths/solidify.md) <sup><mark style="color:$danger;">Refactor<mark style="color:$danger;"></sup>

<figure><img src="../../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure>

The solidify node got a much needed refactor, exposing better controls over the "solidification" process. This is mostly to make it more friendly to use directly with [asset-staging](../../node-library/assets-management/asset-staging/ "mention").

It's doing the same thing as before, but now there are more control exposed:

* Axis order is exposed
  * First axis is the one that will be aligned toward the next point
  * Second axis is the normal
  * Third is the cross axis, but the final transform is kept orthonormal
* Rotation component
  * Rotation components have been exposed so you can pick how the rotation is built

And finally, no matter what the above looks like, bounds are consistently calculated to match a "segment" aspect. Before that it was very left to chance.

### Remap Snapping

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

### Bitmask UI

As part of the UI effort I did a quick pass on the bitmask interface to make it less obscure (and educational almost!) to work with bitmasks.

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

#### [Linetrace](../../node-library/sampling/line-trace.md) Vertex Color

Line trace node can now extract vertex color at the hit location.

<figure><img src="../../.gitbook/assets/image (133).png" alt=""><figcaption></figcaption></figure>



#### Easier search

Added a few helpers/broken down some node to make discovery easier (specifically inclusion)

<div><figure><img src="../../.gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure> <figure><img src="../../.gitbook/assets/image (112).png" alt=""><figcaption></figcaption></figure></div>
