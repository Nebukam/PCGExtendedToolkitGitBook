---
description: Tracking changes since 0.73
icon: tag
---

# v0.74

{% hint style="warning" %}
This version is WIP.
{% endhint %}

0.74 is a big update with important changes; make sure to scan the titles at least in case something would unexpectedly affect your workflow!

{% hint style="danger" %}
There's been some moving around/renaming files again.\
&#xNAN;_&#x53;orry for the svn admin >.<_
{% endhint %}

## Major Tweaks

### Cell Processing

I've pushed a major refactor regarding how cells/contours are detected in clusters. This affects [find-contours.md](../node-library/pathfinding/contours/find-contours.md "mention"), [find-all-cells.md](../node-library/pathfinding/contours/find-all-cells.md "mention"), [find-all-cells-1.md](../node-library/pathfinding/contours/find-all-cells-1.md "mention") and [cluster-surface](../node-library/topology/cluster-surface/ "mention").&#x20;

<details>

<summary> But why?</summary>

The primary reason is that as I added Manhattan and Chebyshev voronoi modes, the topology of the generated cluster became slightly more complex and "rigid" with perfect orthogonal angles that created a LOT of false positive/negative in the existing cell detection code, and it was a mess. _It does naturally create problematic cells that require fusing despite the update_.

I lost of a lot of time trying to fix it without proper success so I ended up taking another more reliable approach entirely : I now build a [Doubly Connected Edge List](https://en.wikipedia.org/wiki/Doubly_connected_edge_list) from the clusters, which is infinitely more reliable than my previous angle-based approach.

</details>

This is an important one as <mark style="color:$warning;">it will break some of your existing settings</mark>; **specifically node count constraints** : the previous code was not counting properly (adding one to all counts), this is not true anymore. That means cell constraints with the old value will not return the same results now.

> For example to isolate quads, you had to use "5" — now it's "4".

Code has been optimized a lot as well and [find-contours.md](../node-library/pathfinding/contours/find-contours.md "mention")rules have changed a bit :

* **Seeds will only capture the cells that&#x20;**_**contains**_**&#x20;their position**, instead of "close enough".\
  &#xNAN;_&#x54;his more closely match functionality of the holes pin of Find All Cells._
* Seeds that are outside of any cells **can only capture the wrapper cell**.

### Data Matching

Data matching got an overhaul — I don't expect a lot of people have used those nodes because it's a fairly niche feature; but it plays a major role in helping reduce the need for loops in a bunch of nodes. The way it worked (and still works) is for most nodes that have "secondary" inputs that synergize with the main inputs (i.e [nearest-point.md](../node-library/sampling/nearest-point.md "mention")), [data-matching](../node-library/misc/data-matching/ "mention") lets you choose which secondary input can be "matched" with the processed ones.

There's new match nodes & tweaked ones:

* [shared-tag.md](../node-library/misc/data-matching/shared-tag.md "mention") now supports additional **Any** and **All**
* [overlap.md](../node-library/misc/data-matching/overlap.md "mention") is now fully implemented and supports recursion

<mark style="color:$danger;">The</mark> [merge-points-by-tag.md](../node-library/misc/merge-points-by-tag.md "mention") <mark style="color:$danger;">has been</mark> <mark style="color:$danger;">deprecated</mark> and instead its functionality has been <mark style="color:$success;">migrated to</mark> [merge-points.md](../node-library/misc/merge-points.md "mention") by adding Data Matching support to it; with overall much greater flexibility.

<figure><img src="../.gitbook/assets/image (140).png" alt=""><figcaption></figcaption></figure>

### Sorting Rule

Not _major_ major but nice QoL, sorting rules can now **read values straight from tags** in the `tag:value` format. This was a necessary addition because of the above change; the old Merge Points by Tag had its own sort-by-tag logic which was nowhere else; and now it's available _everywhere_.

### Heuristics&#x20;

<figure><img src="../.gitbook/assets/image (141).png" alt=""><figcaption></figcaption></figure>

Slightly improved heuristics handling to squeeze some more speed (better caching and allocations etc.) with two new heuristics:

* [hx-turn-penalty.md](../node-library/pathfinding/heuristics/hx-turn-penalty.md "mention")\
  Penalize or favor turns in immediate search. _This is subtely different from_ [hx-inertia.md](../node-library/pathfinding/heuristics/hx-inertia.md "mention") _as the latter builds up on path direction._
* [hx-gradient.md](../node-library/pathfinding/heuristics/hx-gradient.md "mention")\
  Alternative to [hx-attribute.md](../node-library/pathfinding/heuristics/hx-attribute.md "mention") this one favors changes in values between neighbors

> This _should_ not affect existing results.

### Manhattan + Chebyshev

The [voronoi-2d.md](../node-library/clusters/diagrams/voronoi-2d.md "mention") node now supports Manhattan and Chebyshev mode!

<div><figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure> <figure><img src="../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure></div>

{% hint style="warning" %}
Due to the very unique topology of these graph, if you want to find cells you have to use [fuse-clusters.md](../node-library/clusters/fuse-clusters.md "mention") to find point/edge and edge/edge intersections; as some edge perfectly overlap and align, messing with my algorithms.
{% endhint %}

<div><figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption><p>Hull without fuse</p></figcaption></figure> <figure><img src="../.gitbook/assets/image (3).png" alt=""><figcaption><p>Hull after fuse</p></figcaption></figure></div>

### Tensors Extrude Refactoring

Long overdue, I've been doing a lot of cleanup on the tensor side. A few optimizations, and a major overhaul of the [extrude-tensors.md](../node-library/tensors/extrude-tensors.md "mention") code to make it more maintainable and _extendable_.

* Mutators now support a component-wise scale, so you can basically "flatten" effectors.
* More robust extrusions intersection/stop/merge detection

## Asset Staging toolchain

I've solidified the Collection Staging toolchain to make it more useful and leverage more of the various possibilities the system can offer. Following up the recent refactor of the collection architecture and the introduction of the registry on the C++ side, the **Collection Map** workflow is now the preferred approach : <mark style="color:$warning;">this will be reflected in an update of the nodes defaults settings</mark>.&#x20;

> This will affect the [asset-staging](../node-library/assets-management/asset-staging/ "mention") node as well as [spline-mesh](../node-library/paths/spline-mesh/ "mention")

<details>

<summary><strong>Renamed staging  nodes</strong></summary>

| Old Name            | New Name                     |
| ------------------- | ---------------------------- |
| Asset Staging       | **Staging :** **Distribute** |
| Path : Spline Mesh  | **Staging : Spline Mesh**    |
| PCGDataAsset Loader | **Staging : Load PCGData**   |
| Socket Staging      | **Staging : Load Sockets**   |

</details>

<details>

<summary>Why the refocus to collection maps?</summary>

The collection map workflow consist to serialize multiple indices (picks) on the points and output which collections or subcollections are relevant to those picks to a roaming, lightweight mergeable attribute set.

This allows to do all kind of processing operation and data retrieval with minimal attribute overhead (a single `int64`)

I've always wanted to be able to expand the collection system in new ways to make it less of a "narrow" tool; the recent addition of [pcgdataasset-loader.md](../node-library/assets-management/pcgdataasset-loader.md "mention") and the experimental [valency](../working-with-pcgex/valency/ "mention") ecosystem, I started wanting more.

</details>

### Asset Collections custom properties

I'm really happy to say that PCGEx asset <mark style="color:$success;">collections now support custom properties</mark>. It's limited and only supports basic, PCG-friendly types for now.

Properties schema is declared at the collection level with default values, and each field can be overwritten per-entry.&#x20;

> It is **very easily extendable with C++** so you can add really custom stuff if that's your kink. It's relying on `FInstancedStruct` and each struct is responsible for writing data to points/attribute sets.&#x20;
>
> It's leveraging the new [#pcgexproperties-module](v0.74.md#pcgexproperties-module "mention") so you'll only need dependencies on that one and `PCGExCore`.

Segue into the new node used to read those properties back onto the points :

### [Staging  : Load Properties](../node-library/assets-management/staging-load-properties.md) <sup><mark style="color:$success;">New node<mark style="color:$success;"></sup>



## Low level stuff & API

### Data Stealing

A couple of nodes now have the ability to steal data — this is disabled by default, but super handy : the stolen data cost is basically zero.

<div><figure><img src="../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure> <figure><img src="../.gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure> <figure><img src="../.gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure></div>

> This is especially useful for cluster nodes that support it, as duplicating cluster data can grow really expensive.

<details>

<summary>What's that?</summary>

Steal data is really powerful but really risky — be extra careful when using it.

The nodes that expose this option usually do "editing in place", copy the data as-is, change a few properties, output the copy.

When stealing the data is enabled, the node doesn't copy the data and instead modifies the input directly. This saves you from having more extra objects in memory, and is often very welcome.

{% hint style="danger" %}
If stealing data, make absolutely sure that the data pinned into the stealer is exclusively used by that node and no other.
{% endhint %}

</details>

It's currently supported by a few candidates :

* [write-index.md](../node-library/metadata/write-index.md "mention")
* [asset-staging](../node-library/assets-management/asset-staging/ "mention")
* [edge-properties.md](../node-library/clusters/metadata/edge-properties.md "mention")
* [vtx-properties](../node-library/clusters/metadata/vtx-properties/ "mention")
* [write-states](../node-library/filters/write-states/ "mention")
* [centrality.md](../node-library/clusters/centrality.md "mention")
* [meta-cleanup.md](../node-library/quality-of-life/meta-cleanup.md "mention")
* [uber-noise.md](../node-library/metadata/uber-noise.md "mention")
* [path-properties.md](../node-library/paths/path-properties.md "mention")
* [write-guid.md](../node-library/metadata/write-guid.md "mention")
* [uber-filter.md](../node-library/filters/uber-filter.md "mention") _(in write mode)_
* [find-clusters-data-1.md](../node-library/clusters/find-clusters-data-1.md "mention") _(in attribute mode)_
* [uber-blend](../node-library/metadata/uber-blend/ "mention")&#x20;

### PCGExProperties Module

There's a new module to consolidate how I manage custom simple properties exposure. I started having too many different systems doing the same thing but different _(Tuple, Custom collection data, Valency custom module data...)_ so I've **consolidated things into a single module** and refactored other places to use that one solidified approach.

{% hint style="success" %}
Any new custom property will be available to the systems that use them : [tuple.md](../node-library/quality-of-life/tuple.md "mention"), [valency](../working-with-pcgex/valency/ "mention") and [asset-staging](../working-with-pcgex/asset-staging/ "mention")will seamlessly benefit from any additions and improvements.&#x20;
{% endhint %}

> UI Customization is a bit clunky for now; sorry about that. Unreal doesn't make it very friendly to integrate in existing system without extensive hacking; so I had to forfeit a few clicks on complex property types.

## Misc

Edge Filter disambiguation

* "**Edge Filter :&#x20;**<mark style="color:$warning;">**Neighbors Count**</mark>" is now "**Edge Filter :&#x20;**<mark style="color:$success;">**Num Vtx**</mark>"
* "**Vtx Filter :&#x20;**<mark style="color:$warning;">**Neighbors Count**</mark>" is now "**Vtx Filter :&#x20;**<mark style="color:$success;">**Num Edges**</mark>"

> I know it's technically incorrect, but they were really hard to distinguish before.

### Optimizations

* Best Fit Plane has been refactored for speed and approximation - 5-50x speed up depending on cases. Nodes that were previously relying on precise min box now expose a `Precise Min Box` where relevant (true where it was used before)
  * Benefits Clusters, Cell nodes, Points to Bounds etc

### Deprecations

Because [clipper2-offset.md](../node-library/paths/clipper2/clipper2-offset.md "mention") is so good at what it does, I entirely removed the clunky "cleanup" options from the old [offset.md](../node-library/paths/offset.md "mention") node — it was not robust and had ton of edge cases, was a pain to maintain — I'm just happy to get rid of that.



