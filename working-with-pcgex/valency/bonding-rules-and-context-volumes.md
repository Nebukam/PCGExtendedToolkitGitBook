# Bonding Rules & Context Volumes

Bonding Rules are the **compiled data asset** that bridges authoring and runtime. Context Volumes organize your authoring workflow and trigger compilation.

### Bonding Rules: The Compiled Asset

**UPCGExValencyBondingRules** is a data asset containing:

* **Modules**: All unique module definitions (asset + orbital mask + variant)
* **Neighbor relationships**: Which modules can connect on which orbitals
* **Orbital masks**: Precomputed 64-bit masks for fast fitness checks
* **Layers**: Multi-layer orbital sets and neighbor lookups
* **Patterns**: Compiled pattern definitions (if using pattern matching)
* **Properties**: Flattened property arrays with registry
* **Tags**: Module actor tags
* **Metadata**: Module names, weights, constraint settings

#### Creating Bonding Rules Asset

1. **Content Browser**: Right-click → PCGEx → Valency → Bonding Rules
2. **Name descriptively**: `BR_MyModularSystem`, `BR_PipeNetwork`
3. **Don't manually edit** (data is generated by Builder)

The asset itself is mostly **VisibleAnywhere** properties—you view compilation results, not hand-author them.

#### Compiled Data Structure

**Per-module arrays** (index = ModuleIndex):

```cpp
ModuleAssets[]              // Asset references
ModuleWeights[]             // Solver weights
ModuleNames[]               // Optional identifiers
ModuleHasLocalTransform[]   // Whether module has transform variants
ModuleLocalTransformHeaders // Start+count into AllLocalTransforms[]
ModuleTags[]                // Actor tags for filtering
```

**Per-module-per-layer arrays** (index = ModuleIndex \* LayerCount + LayerIndex):

```cpp
ModuleOrbitalMasks[]        // Orbitals with connections
ModuleBoundaryMasks[]       // Orbitals that MUST have NO neighbor
ModuleWildcardMasks[]       // Orbitals that MUST have ANY neighbor
```

**Per-layer structures**:

```cpp
Layers[LayerIndex]:
  OrbitalCount              // How many orbitals in this layer's set
  NeighborHeaders[]         // Start+count for each module+orbital into AllNeighbors
  AllNeighbors[]            // Flattened array of neighbor module indices
```

**Patterns** (if compiled):

```cpp
Patterns:
  Patterns[]                     // All pattern definitions
  ExclusivePatternIndices[]      // Patterns that claim nodes
  AdditivePatternIndices[]       // Patterns that can overlap
```

**Property Registry**:

```cpp
ModulePropertyRegistry[]    // All unique module properties (name, type, supports output)
```

This flattened structure is **optimized for cache efficiency** during off-thread solving.

\[\[SCREENSHOT: Bonding Rules asset showing compiled modules and properties]]

### Context Volumes: Authoring Organization

**AValencyContextVolume** is an editor volume that:

* **Groups authoring data**: Captures all cages within/near bounds
* **References a Bonding Rules asset**: Where compilation output goes
* **Triggers compilation**: Manual button or automatic on changes
* **Optionally regenerates PCG**: Linked PCG components update after build

#### Creating Context Volume

1. **Place in level**: Modes panel → Volumes → Valency Context Volume
2. **Position**: Encompasses all cages you want to include
3. **Configure**:
   * **BondingRules**: Reference your Bonding Rules asset
   * **bAutoRebuild**: Enable for automatic rebuilds on cage changes
   * **PCG Components to Regenerate**: Optional PCG graph triggers

\[\[SCREENSHOT: Context Volume encompassing cages, with details panel]]

#### Capture Behavior

Context Volume collects:

**Cages**:

* All cage actors within volume bounds
* Spatially nearby cages (extends slightly beyond bounds for connections)
* Includes: Regular cages, simple cages, pattern cages, null cages

**Palettes**:

* All palette actors referenced by captured cages (via MirrorSources)
* Palettes can be outside volume bounds (they're lightweight references)

**Orbital Sets**:

* Extracted from cages and patterns
* Compiled into layer definitions

#### Multi-Volume Aggregation

**Multiple volumes can contribute to the same Bonding Rules asset**:

* Each volume with same `BondingRules` reference adds its cages
* Builder **aggregates all volumes** with matching asset
* Result: One bonding rules asset from multiple spatial regions

**Use cases**:

* Large levels split across volumes
* Different teams working on separate areas
* Modular level sections with shared rule set

**Example**:

```
Volume_Section_A: References BR_Building, captures cages 1-20
Volume_Section_B: References BR_Building, captures cages 21-40
Result: BR_Building contains all 40 cages' modules
```

\[\[SCREENSHOT: Multiple volumes in level referencing same bonding rules]]

### The Builder: Compilation Process

The **Builder** (UPCGExValencyBondingRulesBuilder) is invoked when you click **"Build Rules from Cages"** on a Context Volume.

#### Build Steps

```
1. AGGREGATE VOLUMES
   - Find all volumes with same BondingRules reference
   - Collect all cages from all volumes

2. COLLECT CAGE DATA
   - For each cage:
     - Get effective assets (cage + mirror sources)
     - Get effective properties
     - Get effective tags
     - Compute orbital masks from connections
     - Store in intermediate structure

3. BUILD MODULE MAP
   - For each cage's assets:
     - Compute module key: Hash(Asset, OrbitalMask, MaterialVariant)
     - If new key → create new module definition
     - If existing key → accumulate local transforms (if enabled)
   - Result: Unique modules array

4. BUILD NEIGHBOR RELATIONSHIPS
   - For each cage's orbitals with connections:
     - Find connected cages
     - For each connected cage's assets:
       - Build neighbor module key
       - Add to source module's orbital neighbor list
   - Handle null cages (boundary/wildcard constraints)
   - Result: Neighbor lookup tables per layer

5. COMPILE PATTERNS (if pattern cages exist)
   - Detect connected pattern cage networks
   - For each root pattern cage:
     - Traverse network to build topology
     - Resolve proxied cages to module indices
     - Compute adjacency (entry-to-entry connections)
     - Store pattern settings
   - Sort into exclusive vs additive patterns

6. FLATTEN & OPTIMIZE
   - Convert per-module data to flat arrays
   - Build neighbor headers (start+count indices)
   - Compute property registry
   - Serialize to bonding rules asset

7. MARK DIRTY & SAVE
   - Mark bonding rules asset dirty
   - Save asset (if auto-save enabled)
```

#### Build Logs

Builder outputs to console (with optional verbosity):

```
PCGEx.Valency.Log.SetVerbosity Building Info
```

**Typical output**:

```
Building bonding rules...
Found 15 cages (12 regular, 2 pattern, 1 null)
Created 25 modules (3 variants per cage)
Built 2 layers (Cardinal4, Diagonal8)
Compiled 2 patterns (1 exclusive, 1 additive)
Property registry: 5 properties
Build complete in 45ms
```

**Errors logged**:

* Cage with no connections (no module created)
* Property name collision with different types
* Pattern cage not part of connected network
* Orbital set mismatch across layers

\[\[SCREENSHOT: Builder log output showing compilation results]]

### Manual vs Auto Rebuild

#### Manual Rebuild

**Context Volume**: "Build Rules from Cages" button (always available)

* Works whether editor mode is active or not
* Explicit control over when compilation happens
* Use for: Finalized designs, performance (avoid constant rebuilds)

#### Auto Rebuild

**Context Volume**: `bAutoRebuild = true`

* Triggers on cage changes (move, connection edit, property change)
* Requires **Valency editor mode active**
* Uses dirty state coalescing (defers until next frame)

**Triggering events**:

* Cage moved
* Orbital connection added/removed
* Cage property modified
* Palette contents changed (propagates to dependent cages)

**Dirty state manager**: Coalesces multiple rapid changes into single rebuild (avoids rebuild spam).

**Use for**: Active design iteration—see changes reflected immediately.

### Using Bonding Rules in PCG Graph

Once compiled, reference the Bonding Rules asset in your PCG graph:

**Valency Staging node**:

* **BondingRules** pin: Soft object reference to your asset
* Asset is **loaded at graph execution time**
* Contains all modules, neighbor rules, properties

**Asset loading**: Uses `PCGExHelpers::LoadBlocking_AnyThread()` for thread-safe loading (PCG runs off game thread).

\[\[SCREENSHOT: PCG graph with Valency nodes, BondingRules referenced]]

### Viewing Compiled Data

**In Bonding Rules asset**:

**Modules tab**: View all compiled modules

* Module index
* Asset reference
* Orbital masks (displayed as hex or binary)
* Properties
* Tags

**Property Registry**: View all discovered properties

* Property name
* Type name
* Whether it supports attribute output

**Patterns**: View compiled patterns (if any)

* Pattern name
* Entry count
* Exclusivity
* Output strategy

**Layers**: View layer configuration

* Orbital count
* Orbital set reference

Use this to verify compilation produced expected results.

### Best Practices

#### Organize Volumes Spatially

Keep volumes aligned with level structure:

* One volume per building section
* One volume per terrain zone
* Overlaps are fine (cages captured by nearest volume)

#### Name Bonding Rules Descriptively

`BR_` prefix + system name:

* `BR_Building_Modular`
* `BR_PipeNetwork`
* `BR_DungeonTiles`

#### Version Bonding Rules

For major changes, duplicate asset:

* `BR_MySystem_v1`, `BR_MySystem_v2`
* Test new version without breaking existing graphs

#### Check Build Logs

After every build:

* Verify expected module count
* Check for errors (property collisions, missing connections)
* Validate layer configuration

#### Disable Auto Rebuild for Large Systems

If you have 100+ cages:

* Auto rebuild gets slow
* Manual rebuild when iteration phase complete

#### Save Intermediate Progress

Builder can take time on large systems:

* Save level regularly
* Bonding Rules asset is saved automatically on build (if enabled)

#### Test Compilation Early

Don't author 50 cages then build first time:

* Build with 5 cages
* Verify pipeline works
* Expand incrementally

### Common Issues

**"No modules created after build"**

* Check cages have orbital connections (disabled orbitals = no connections = no module)
* Verify cages are within volume bounds
* Check build log for errors

**"Module count way higher than expected"**

* Likely: Material variants or transform variants creating separate modules
* Check if local transforms accidentally in module key (bug if so)
* Review cage asset entries

**"Patterns not appearing in compiled data"**

* Pattern cages must be connected (form network)
* Pattern network needs exactly one root cage (bIsPatternRoot = true)
* Check pattern cage orbitals are enabled

**"Properties missing from registry"**

* Property name collision with different types (build error logged)
* Property component not on cage (check hierarchy)
* Property not set to output (some properties don't support it)

**"Multi-volume aggregation not working"**

* Verify all volumes reference **exact same** bonding rules asset (not duplicates)
* Check each volume's capture bounds includes its cages
* Rebuild from any volume (all are aggregated)

**"Auto rebuild not triggering"**

* Ensure Valency editor mode is active (toolbar button)
* Check `bAutoRebuild = true` on volume
* Some changes require manual rebuild (rare edge cases)

***

**Next:** Patterns & Pattern Replacement — Detecting and transforming module arrangements
